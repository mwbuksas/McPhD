module MonteCarlo where
{- | Take application-specific stepping functions, particle event and tally
data and combine them into a Monte Carlo simulation.
-}

import Data.Monoid

import Properties

-- | Outcomes are a distance to an event, the event and the next
-- particle state. These are generated by each contractor, and the
-- 'winner' is selected for each step.
-- data Outcome e p = Outcome {
--   distance   :: !Distance   -- ^ Strict, becuase we use it to select winners.
--   , event    :: e
--   , particle :: p
--   }


-- type Contractor model event particle
--     = model -> particle -> Outcome event particle



-- | A version of stream without a type to bind the results. All of
-- the other information needs to be stored in the event.
stream :: (p -> (e, p))  -- ^ Function to generate the next state and event.
        -> (e -> Bool)    -- ^ Check for terminal events to stop streaming
        -> p              -- ^ Initial particle
        -> [(e,p)]        -- ^ Resulting list of events and particle states.

stream stepfn continue p = next p
    where next q =
              let ( e, q' ) = stepfn q
              in  ( e, q' ) : if not $ continue e then [] else next q' 
                  

-- | Stream a single particle:
-- stream :: (p -> Outcome e p)  -- ^ Function to produce each step. Comes from a model.
--        -> (e -> Bool)         -- ^ Check for terminal events to stop streaming
--        -> p                   -- ^ Initial particle
--        -> [Outcome e p]       -- ^ Resulting list of events and particle states.
          
-- stream stepfn continue p = next p
--     where next q =
--               let outcome@(Outcome _ e q') = stepfn q
--               in  outcome : if continue e then next q' else []
                  

-- | A helper function for collapsing Monoid tallies.
monoidTally :: (Monoid t) => (d -> t) -> [d] -> t
monoidTally toTally datums = mconcat (map toTally datums)


-- | This is the top-level structure of the MonteCarlo algorithm.
simulate :: (p->tc) -> (t->tc->t) -> t -> [p] -> t
simulate makeTally -- ^ Maps particles to a tally contribution
         foldTally -- ^ Combines tally contibutions with a complete tally
         initTally -- ^ Initial value of the tally
         particles -- ^ A list of particles
             = foldl foldTally initTally (map makeTally particles)
